a<-matrix(3,3)
install.package("combinat")
install.packages("combinat")
library('combinat')
require(combinat)
combn(4,2)
choose(4,2)
propensity<-function(rate,n,left_num){
return(rate*choose(n,left_num))
}
propensity<-function(rate,n,left_num){
return(rate*prod(choose(n,left_num)))
}
propensity(1,(100,100),(1,2))
choose(100,1)
prod(choose(100,1),choose(100,2))
library(ape)
install.packages(ape)
"ape"
install.packages(c("RUnit",'ape'))
library(ape)
get_node_children = function(node, tree) {
# Return the two child nodes of the given node.
# In a bifurcating tree, a node will have either two child nodes if it is an internal node,
# or zero child nodes if it is a tip node.
# For an internal node, return the two child node numbers, for a tip node return NULL.
#   node: the node for which child nodes should be returned
#   tree: the tree encoded in an object of class phylo
if (node <= length(tree$tip.label)) {
return(NULL)
}
children = which(tree$edge[, 1] == node)
child1 = tree$edge[children[1], 2]
child2 = tree$edge[children[2], 2]
# Return the indices of the child nodes.
#   child1: first child of the given node
#   child2: second child of the given node
return(list(child1 = child1,
child2 = child2))
}
get_root = function(tree) {
# Returns the number of the root node of the given tree.
return(length(tree$tip.label) + 1)
}
is_tip = function(node, tree) {
# Returns TRUE if the given node is a tip, FALSE otherwise
return(node <= length(tree$tip.label))
}
initialize_description = function(tree, traits_at_tip) {
# This function creates a list whith two matrices and one vector.
#
# The first matrix is called traits and stores the values of the two traits at the nodes of
# the tree. Here we initialize this matrix with the given trait values at the tips and NA for
# the internal nodes. The values for the internal nodes have to be calculated in the
# function get_contrasts_in_subtree(). The row numbers correspond to the node numbers in the tree,
# i.e. for a tree with N tips the first N rows correspond to the tips, the last N-1 rows to the
# internal nodes.
#
# The second matrix is called normalized_contrasts and stores the values of the normalized contrasts
# for both traits at all nodes. The matrix will be filled out in the function
# get_contrasts_in_subtree(). Again, the row numbers correspond to the node numbers allocated in tree.
# As contrasts are only calculated at the internal nodes, the first N rows of this matrix will stay
# undefined, i.e. NA, as set here.
#
# The third object in the list is a vector that holds the corrected branch lenghts which will be
# calculated in the function get_contrasts_in_subtree(). It is initialized with the original branch lengths.
# The branches are ordered by the node which they lead to, e.g. branch_lengths[3] will give the branch that
# leads to node 3. The branch leading to the root will always be NA. Bear in mind that if you implement the
# tree walikng correctly, you will only need this data structure to compute all the corrected branch lengths,
# you do not need to store the uncorrected values separately.
number_of_tips = length(tree$tip.label)
# initialize the trait_matrix
trait_matrix = matrix(NA, nrow = 2 * number_of_tips - 1, ncol = 2,
dimnames = list(1:(2 * number_of_tips - 1),
c("value_of_trait1", "value_of_trait2")))
# fill in the known trait values
trait_matrix[1:length(tree$tip.label), ] = cbind(as.numeric(traits_at_tip$trait1[tree$tip.label]),
as.numeric(traits_at_tip$trait2[tree$tip.label]))
# initialize the normalized_contrasts matrix
contrast_matrix = matrix(NA, nrow = 2 * number_of_tips - 1, ncol = 2,
dimnames = list(1:(2 * number_of_tips - 1),
c("normalized_contrast_trait1", "normalized_contrast_trait2")))
# initialize the branch lengths
branch_lengths = c(tree$edge.length, NA)[order(c(tree$edge[, 2], length(tree$tip) + 1))]
# Return the three objects in one list
return(list(traits = trait_matrix, normalized_contrasts = contrast_matrix, corrected_branch_lengths = branch_lengths))
}
plot_data_and_regression = function(tree, description, summary_linear_regression) {
# This function displays two plots:
# On the left side the raw data points and the linear regression on the raw data, and
# On the right side the contrast values and the linear regression on the contrasts.
# As input this function takes two lists that will be generated by the following functions:
#   description: a list as produced by get_contrasts_in_subtree
#   summary_linear_regression: a list of two vectors with named values corresponding to the slope, intercept, p.value and R2
#							   for the linear regression on respectively the raw data and the contrasts, as produced by get_trait_correlation
par(mfrow = c(1, 2))
raw = data.frame(description$traits[1:length(tree$tip.label), ])
plot(raw, pch = 16, main = "raw data")
x = seq(range(raw[, "value_of_trait1"])[1], range(raw[, "value_of_trait1"])[2], by = 0.01)
lines(x, summary_linear_regression$linear_regression_raw_data["slope"] * x +
summary_linear_regression$linear_regression_raw_data["intercept"],
col = "gray")
legend("bottomright", bty = "n", cex = 0.7,
legend = paste0(names(summary_linear_regression$linear_regression_raw_data),
"=", signif(summary_linear_regression$linear_regression_raw_data, 3), 4))
cont = data.frame(description$normalized_contrasts[(length(tree$tip.label) + 1):(2 * length(tree$tip.label) - 1), ])
plot(cont, pch = 17, main = "contrasts")
x = seq(range(cont[, "normalized_contrast_trait1"])[1], range(cont[, "normalized_contrast_trait1"])[2], by = 0.01)
lines(x, summary_linear_regression$linear_regression_contrasts["slope"] * x +
summary_linear_regression$linear_regression_contrasts["intercept"],
col = "gray")
legend("bottomright", bty = "n", cex = 0.7,
legend = paste0(names(summary_linear_regression$linear_regression_contrasts),
"=", signif(summary_linear_regression$linear_regression_contrasts, 3), 4))
}
#########################################################
######    Code above this should not be changed   #######
######    or deleted.                             #######
#########################################################
linear_regression = function(values1, values2) {
# Perform a simple linear regression on two sets of given values to evaluate the possible correlation between them.
# The regression is approximated by the intercept alpha and the slope beta, values2 = alpha + beta*values1.
# The input values should be presented as vectors, in the same order:
# i.e. if the position i in values1 represents the value of trait or contrast at a certain node n, the same position i in values2
# should represent the value for the other trait or contrast at the same node n.
#   values1: first ordered vector of values
#   values2: second ordered vector of values
s<-summary(lm(y~x, data.frame(x = values1,y = values2)))
slope<-s$coefficients[2,1]
intercept<-s$coefficients[1,1]
p.value<-s$coefficients[2,4]
R2<-s$r.squared
# Return a vector with named values that summarizes the linear regression result.
#   slope: the slope of the linear regression line (beta)
#   intercept: the intercept of the linear regression line (alpha)
#   p.value: p-value, the level of significance of the correlation.
#   R2: R squared, the measure of how close the data are to the fitted regression line.
return(c(slope = slope, intercept = intercept, p.value = p.value, R2 = R2))
}
calculate_trait_at_internal_node = function(trait_child1, trait_child2, branch_length_to_child1, branch_length_to_child2) {
# Calculate the trait value at an internal node given the values of this trait at the
# two child nodes and the branch lengths connecting these child nodes to the parent node.
#   trait_child1: trait value at first child
#   trait_child2: trait value at second child
#   branch_length_to_child1: branch length leading to first child
#   branch_length_to_child2: branch length leading to second child
trait_at_internal_node<-(trait_child1*branch_length_to_child2+trait_child2*branch_length_to_child1)/(branch_length_to_child1+branch_length_to_child2)
# Return the estimated value of the trait at the internal node.
return(trait_at_internal_node)
}
calculate_contrast = function(trait_child1, trait_child2, branch_length_to_child1, branch_length_to_child2) {
# Calculate the normalized contrast at a given node given the values of a trait at the two child nodes
# and the branch lengths connecting these child nodes to the parent node.
# trait_child1: trait value at first child
# trait_child2: trait value at second child
# branch_length_to_child1: branch length leading to first child
# branch_length_to_child2: branch length leading to second child
contrast<-(trait_child1-trait_child2)/sqrt(branch_length_to_child1+branch_length_to_child2)
# Return the numerical value of the normalized contrast.
return(contrast)
}
calculate_corrected_branch_length = function(node, child1, child2, corrected_branch_lengths) {
# Calculate the corrected branch length leading to the given node.
#   node: the node at the end of the branch to be corrected
#   child1: the first child of the given node
#   child2: the second child of the given node
#   corrected_branch_lengths: the current vector of corrected branch lengths, where all branches
#                             below the given node have already been corrected
corrected_length<-corrected_branch_lengths[child1]*corrected_branch_lengths[child2]/(corrected_branch_lengths[child1]+corrected_branch_lengths[child2])+corrected_branch_lengths[node]
# Return the numeric value of corrected branch lengths
return(corrected_length)
}
calculate_trait_and_contrast = function(child1, child2, traits, corrected_branch_lengths) {
# Calculate the trait value and the normalized contrast value at a node given the indices of the node children.
#   child1: the first child of a given node
#   child2: the second child of a given node
#   traits: a vector containing trait values for all nodes
#   corrected_branch_lengths: the current vector of corrected branch lengths, where all branches
#                             below the node in question have already been corrected
trait_value<-calculate_trait_at_internal_node(traits[child1],traits[child2],corrected_branch_lengths[child1],corrected_branch_lengths[child2])
contrast<-calculate_contrast(traits[child1],traits[child2],corrected_branch_lengths[child1],corrected_branch_lengths[child2])
# Return the trait value and the normalized contrast value at the given node.
#   trait_value: the numerical value for the trait at given node
#   contrast: the numerical value for the contrast at given node
return(list(trait_value = trait_value, contrast = contrast))
}
get_contrasts_in_subtree = function(node, tree, description) {
# Calculate the normalized independent contrasts, trait values, and corrected branch lengths
# for the subtree that stems from the given node.
#   node: the node for which the contrasts should be calculated
#   tree: the tree encoded in an object of class phylo
# 	description: a list containing 3 entries:
#				 a matrix with the current trait values at all nodes (including tips) in the tree (value or NA)
#				 a matrix with the current contrasts at the internal nodes (value or NA), and
#				 a vector with the corrected branch lengths.
#				 This list is initialized by the provided function initialize_description().
# If the node is a tip, return the same description.
# Otherwise, get the child nodes of the given node and compute the corrected branch lengths, normalized contrasts and trait values
# for the child nodes, saving the updated description.
if(is_tip(node,tree)==TRUE){
updated_description<-description
}
# Update the branch length leading to the given node, save it in the description
# Compute the trait values and normalized contrasts for both traits, save the values in the description
if(is_tip(node,tree)==FALSE){
child1<-get_node_children(node,tree)$child1
child2<-get_node_children(node,tree)$child2
description<-get_contrasts_in_subtree (child1, tree, description)
description<-get_contrasts_in_subtree (child2, tree, description)
description$corrected_branch_lengths[node]<-calculate_corrected_branch_length(node,child1,child2,description$corrected_branch_lengths)
trait1_contrast1<-calculate_trait_and_contrast(child1,child2,description$traits[,'value_of_trait1'],description$corrected_branch_lengths)
trait2_contrast2<-calculate_trait_and_contrast(child1,child2,description$traits[,'value_of_trait2'],description$corrected_branch_lengths)
description$traits[node,'value_of_trait1']<-trait1_contrast1$trait_value
description$traits[node,'value_of_trait2']<-trait2_contrast2$trait_value
description$normalized_contrasts[node,'normalized_contrast_trait1']<-trait1_contrast1$contrast
description$normalized_contrasts[node,'normalized_contrast_trait2']<-trait2_contrast2$contrast
updated_description<-description
}
# Return a list with updated trait values, normalized contrasts, and corrected branch lenghts.
#   updated_description: list with structure as defined in the initialize_description() function.
return(updated_description)
}
get_trait_correlation = function(newick_tree, traits_at_tip) {
# Compute the normalized contrasts for the whole tree and determine whether there is a correlation between
# the contrasts.
#   newick_tree: the tree in newick text format
#   traits_at_tips: a list of two vectors that represent the two trait values observed for the
#                   individuals at the tips.
# Transform the tree from text format to an object of the phylo class
tree = read.tree(text = newick_tree)
# Reorder the tree for easier traversing
tree = reorder(tree, order = "cladewise")
# Initialize the list of traits, contrasts and branch lengths
initial_description<-initialize_description(tree, traits_at_tip)
# Calculate the new trait values at all the nodes in the tree, normalized contrasts at the internal nodes and the
# corrected branch lengths, starting at the root of the tree.
root<-get_root(tree)
updated_description<-get_contrasts_in_subtree(root,tree,initial_description)
# Perform linear regression on the traits at the tips and get the slope, intercept, P-value, and R2-value
raw_data_regression<-linear_regression(unlist(traits_at_tip[1],use.names = FALSE),unlist(traits_at_tip[2],use.names = FALSE))
# Perform linear regression on the normalized contrasts and get the slope, intercept, P-value, and R2-value
contrasts_regression<-linear_regression(updated_description$normalized_contrasts[,'normalized_contrast_trait1'],updated_description$normalized_contrasts[,'normalized_contrast_trait2'])
# Plot the two linear regression results
summary_linear_regression <- list(linear_regression_raw_data = raw_data_regression,
linear_regression_contrasts = contrasts_regression)
plot_data_and_regression(tree, updated_description, summary_linear_regression)
return(summary_linear_regression)
}
test_trait_correlation = function() {
newick_tree = "(unicorn:15,(orangutan:13,(gorilla:10.25,(human:5.5,chimp:5.5):4.75):2.75):2);"
traits_at_tip = list(trait1 = c(unicorn=5, orangutan=2, gorilla=9, human=1, chimp=4),
trait2 = c(unicorn=6, orangutan=5, gorilla=15, human=3, chimp=9))
print(get_trait_correlation(newick_tree, traits_at_tip))
}
#test_trait_correlation()
View(test_trait_correlation)
BiocManager::install(c("rtracklayer", "GenomicRanges"))
BiocManager::valid()
BiocManager::available("TxDb.Hsapiens")
browseVignettes("simpleSingleCell")
library("rtracklayer")
library("GenomicRanges")
install.packages("rtracklayer")
updateR()
install.packages("installr"); library(installr)
install.packages("installr")
library(devtools)
install.packages("devtools")
library(devtools)
library("devtools")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("rtracklayer")
if (!"BiocManager" %in% rownames(intalled.packages()))
install.packages("BiocManager", repos="https://cran.r-project.org")
if (!"BiocManager" %in% rownames(intalled.packages()))
install.packages("BiocManager", repos="https://cran.r-project.org")
install.packages(c("ggplot2", "tibble"))
library("ggplot2")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("rtracklayer")
library('rtracklayer')
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("rtracklayer")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("GenomicRanges")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("rtracklayer")
library("rtracklayer")
library("rtracklayer")
library("GenomicRanges")
fname <- file.choose()
fname <- file.choose()
fname
file.exists(fname)
cpg <- import(fname)
cpg
cpg <- keepStandardChromosomes(cpg, pruning.mode = "coarse")
cpg
knitr::opts_chunk$set(echo = TRUE)
library("rtracklayer")
library("GenomicRanges")
cpg
head(start(cpg))
head(cpg$name)
hist(log10(width(cpg)))
head(seqnames(cpg))
head(end(cpg))
head(strands(cpg))
head(strand(cpg))
# select the CpG islands on chromosomes 1 and 2
subset(cpg,seqnames %in% c("chr1","chr2"))
## Genomic annotations
library("TxDb.Hsapiens.UCSC.hg38.knownGene")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
## Genomic annotations
library("TxDb.Hsapiens.UCSC.hg38.knownGene")
# Extract the coordinates of all transcripts
tx <- transcripts(TxDb.Hsapiens.UCSC.hg38.knownGene)
tx
# keep only the standard chromosomes to work with cpg object
tx <- keepStandardChromosomes(tx, pruning.mode = "coarse")
tx
# count the number of CpG islands that overlap each transcript
olaps <- countOverlaps(tx,cpg)
length(olaps)
table(olaps)
install.packages('airway')
BiocManager::install("airway")
library("airway")
setwd("~/Bioinformatics-100-days/day1")
srp <- read.csv("SraRunInfo.csv")
srpsmall <- srp[,c("Run","avgLength","Experiment","Sample","BioSample","SampleName")]
View(srpsmall)
View(srpsmall)
install.packages('getGEO')
BiocManager::install('GEOquery')
## working with summarized experimental data
library("GEOquery")
geofile <- getGEO("GSE52778",GSEMatrix = TRUE)
gse <- getGEO("GSE52778",GSEMatrix = TRUE)
pdata <- pData(gse)[,grepl("ch1",names(pData(gse)))]
names(pdata) <- c("treatment","tissue","ercc_mix","cell","celltype")
pdataclean <- data.frame(treatment=sub("treatment: (.*)","\\1",pdata$treatment),
cell=sub("cell line: (.*)","\\1",pdata$cell),
row.names=rownames(pdata))
pdataclean$dex <- ifelse(grepl("Dex",pdataclean$treatment),"trt","untrt")
pdataclean$albut <- ifelse(grepl("Albut",pdataclean$treatment),"trt","untrt")
pdataclean$SampleName <- rownames(pdataclean)
pdataclean$treatment <- NULL
pdata <- pData(gse)[,grepl("ch1",names(pData(gse)))]
library('airway')
pData(gse[[1]])
pData(gse)
pData(gse[1])
pData(gse[[1])
pData(gse[[1]])
pdata <- pData(gse[[1]])[,grepl("ch1",names(pData(gse[[1]])))]
View(pdata)
names(pdata) <- c("treatment","tissue","ercc_mix","cell","celltype")
pdataclean <- data.frame(treatment=sub("treatment: (.*)","\\1",pdata$treatment),
cell=sub("cell line: (.*)","\\1",pdata$cell),
row.names=rownames(pdata))
pdataclean$dex <- ifelse(grepl("Dex",pdataclean$treatment),"trt","untrt")
pdataclean$albut <- ifelse(grepl("Albut",pdataclean$treatment),"trt","untrt")
pdataclean$SampleName <- rownames(pdataclean)
pdataclean$treatment <- NULL
View(pdata)
rownames(coldata) <- coldata$Run
coldata <- merge(pdataclean, srpsmall, by="SampleName")
rownames(coldata) <- coldata$Run
coldata <- coldata[coldata$albut == "untrt",]
rownames(coldata) <- coldata$Run
coldata <- coldata[coldata$albut == "untrt",]
coldata$albut <- NULL
coldata
data("airway")
airway
counts(airway)
airway(counts)
library("airway")
data(airway)
colData <- as.data.frame(colData(airway))
counts <- as.data.frame(assat(airway))
counts <- as.data.frame(assay(airway))
View(counts)
# creatins a SummarizedExperiment object
library("SummarizedExperiment")
se <- SummarizedExperiment(assays = counts, colData = colData)
se <- SummarizedExperiment(assay = counts, colData = colData)
# object construction
colData <- as.data.frame(colData(airway))
counts <- as.data.frame(assay(airway))
se <- SummarizedExperiment(assay = counts, colData = colData)
se <- SummarizedExperiment(assay = counts, colData = coldata)
View(colData)
View(counts)
data(airway)
# object construction
colData <- as.data.frame(colData(airway))
counts <- as.data.frame(assay(airway))
# creatins a SummarizedExperiment object
library("SummarizedExperiment")
se <- SummarizedExperiment(assay = counts, colData = colData)
se
subset(se, , dex == "trt")
# calculate the library size
colSums(assay(se))
## downstream analysis
library('DESeq2')
BiocManager::install('DESeq2')
